\lecture{Линейные коды}{А. Рязанов}{И. Агафонова}

\section{Базовые факты, коды Адамара}
\begin{definition}
Код называется линейным, если множество кодовых слов $C$ является
линейным подпространством $\tw^n$.
\end{definition}

\begin{definition}
Весом Хэмминга $a \in \tw^n$ назовем $w(a) = \{i \colon a_i = 1\}$
\end{definition}

\begin{remark}
$d(a,b) = w(a \oplus b)$
\end{remark}

\begin{lemma}
Пусть $C$ --- линейный код. Тогда $d(C) = \min\limits_{\substack{x \in C \\ x \neq 0}} w(x)$
\end{lemma}
\begin{proof}
$d(C) = \min\limits_{a\neq b \in C} d(a,b) =\min\limits_{a\neq b \in C} w(a \oplus b) =
 \min\limits_{\substack{x \in C \\ x \neq 0}} w(x)$
\end{proof}

\begin{definition}
Пусть $C$ --- некоторый линейный код с порождающей матрицей $G$ и проверочной
матрицей $H$. Тогда дуальным к нему называется код $C^{\bot}$ с порождающей
матрицей $H$ и проверочной матрицей $G$.

Если $C$ являлся $(n,k)$-кодом, то $C^{\bot}$ будет $(n,n-k)$-кодом.
\end{definition}


\begin{theorem}
Дуальный код Хэмминга $(2^m-1, 2^m-1-m)$ является кодом Адамара с матрицей
Сильвестра.
\end{theorem}

\begin{proof}
Будем доказывать по индукции.

{\bfseries База:} $m=2$. Тогда $n = 2^m - 1 = 3$, $k=2^m-1-m = 1$.
Тогда проверочная матрица такого кода Хемминга имеет вид 
$\begin{pmatrix} 0 &1 &1 \\ 1 & 0 & 1 \end{pmatrix}$
Тогда все векторы дуального кода выглядят как:
$\begin{pmatrix} 0 & 0 & 0 \\
                 0 & 1 & 1 \\
                 1 & 0 & 1 \\
                 1 & 1 & 0 \\
 \end{pmatrix}$.
Этот код совпадает с соответствующим кодом Адамара.

{\bfseries Переход:} пусть доказано для $n = 2^{m-1} - 1$.
Пусть $\bar{H} \in \tw^{(m-1) \times 2^{m-1}}$ --- проверочная матрица для кода Хэмминга
$(2^{m-1} - 1, 2^{m-1} - 1 - (m-1))$.

Покажем, что матрица 
$$ H = \begin{pmatrix}
            0 \ldots 0 & 1 & 1 \ldots 1 \\
               \bar{H} & \mathbf{0}_{m-1} & \bar{H}
        \end{pmatrix}$$
является проверочной матрицей кода Хэмминга $(2^m-1, 2^m - 1 - m)$.
Это почти очевидно, достаточно заметить, что столбцы матрицы
различны и ее размерность $m \times (2^m-1)$ (следует из
того же свойства для $\bar{H}$ и отсутствия в $\bar{H}$ нулевого
столбца. 

По индукционному предположению матрица $\bar{H}$ порождает строки
матрицы $\mathcal{A}'$ --- усеченной бинарной матрицы Адамара размера
 $2^{m-1} \times 2^{m-1} - 1$. Тогда матрица 
 $(\bar{H} | \mathbf{0}_{m-1} | \bar{H})$ порождает строки
 матрицы $(\mathcal{A}' | \mathbf{0}_{2^{m-1}} | \mathcal{A}')$.
 
Добавим в $(\bar{H} | \mathbf{0}_{m-1} | \bar{H})$ первую строку $H_1$,
чтобы получить матрицу $H$. Тогда можно сделать вывод, что
матрица $H$ порождает все строки матрицы 
$(\mathcal{A}' | \mathbf{0}_{2^{m-1}} | \mathcal{A}')$ и
строки, полученные из них прибавлением $H_0$. Тогда в
итоге мы получим коды
$$\begin{pmatrix}
    \mathcal{A}' & \mathbf{0}_{2^{m-1}} & \mathcal{A}' \\
    \mathcal{A}' & \mathbf{1}_{2^{m-1}} & \mathbf{1} - \mathcal{A}'
   \end{pmatrix}$$

Припишем слева столбец из нулей и получим, что новая матрица
--- это в точности матрица, полученная из 
$(\mathbf{0}_{2^{m-1}} | \mathcal{A}')$ по правилу Сильвестра.
Таким образом, теорема доказана.

\end{proof}

\begin{corollary}
Код Адамара с матрицей Сильвестра является линейным.
\end{corollary}

\begin{theorem}
Пусть $C$ --- линейный код, $H$ --- его проверочная матрица.
\begin{enumerate}
\item В проверочной матрице $H$  любые $d-1$ столбцов
линейно независимы $\iff$ $d(C) \ge d$
\item Если любые $d-1$ столбцов матрицы $H$ линейно независимы и
существуют $d$ линейно зависимых столбцов, то $d(C) = d$
\end{enumerate}
\end{theorem}

\begin{proof}

$\Rightarrow$

По лемме $d(C) = \min\limits_{x \in C} w(x)$. Пусть существует
$x \in C$ такое, что $w(x) < d$. $Hx = 0$. Пусть $i_1, \ldots, i_r$
--- номера ненулевых компонент $x$ ($r < d$). Тогда
 $H_{i_1} \oplus H_{i_2} \oplus \ldots \oplus H_{i_r} = 0$,
 но это противоречит условию линейной независимости столбцов.
 
$\Leftarrow$

Если $H_{i_1} \oplus \ldots \oplus H_{i_r} = 0$, то
рассмотрим вектор $x = \{x_j\}$, 
$x_j = \begin{cases} 0 & \exists l \colon j = i_l \\
                     1 & \text{ иначе} \end{cases}$,
Для такого вектора $Hx = 0$, но $w(x) = r < d$.

Пункт 2 непосредственно следует из пункта 1.
\end{proof}

\section{Смежные классы и декодирование по синдрому}

\begin{definition}
Смежным классом группы $G$ по подгруппе $C$ называется множество вида
$$\begin{array}{rl}Cb = \{x b \colon x \in C\} & \text{ правый } \\
                  bC= \{ b x \colon x \in C\} & \text{ левый }
\end{array}$$
\end{definition}

\begin{definition}
Синдром вектора $x$ относительно линейного кода $C$ с проверочной
матрицей $H$ называется вектор $Hx$
\end{definition}

\begin{theorem} 
Пусть $x,y \in \tw^n$. Тогда $x,y \in Cz$ для некоторого $z$ $\iff$
$Hx = Hy$
\end{theorem}

\begin{proof}
$\Rightarrow$ $x = a + z, \, y = b + z$, $a,b \in C$. Тогда
   $$Hx = Ha + Hz = Hz = Hb + Hz = Hy$$

$\Leftarrow$ $Hx = Hy \implies H (x + y) = 0$, тогда $x,y \in C x$.
\end{proof}

Пусть $b \in C$, $b' = b + e$, где $e$ --- вектор ошибок. Тогда
$H b' = He$, то есть, ошибку для $b'$ нужно искать в его смежном
классе по $C$.

{\bfseries Лидер} --- это слово наименьшего веса в смежном классе.
Лидер является наиболее вероятным вектором ошибок.

\begin{proposition}
Будем полагать вектором ошибок лидера соответствующего смежного класса.
Составим матрицу $A = \{A_{ij}\}_{2^{n-k} \times 2^k}$, $A_{i,0}$ ---
лидер смежного класса $i$, $A_{0,i} \in C$ и $A_{ij} = A_{i,0} \oplus
A_{0,j}$.
\begin{enumerate}
\item Исправим все ошибки, являющиеся лидерами
\item Для любого слова $A_{ij}$ слово $A_{0,j}$ является ближайшим к
     $A_{ij}$ кодовым словом.
\end{enumerate}
\end{proposition}

\begin{proof}
\begin{enumerate}
\item Очевидно
\item $A_{ij} = A_{0,j} + A_{i,0}$. $A_{i,0}$ --- лидер. 
      $d(A_{ij}, A_{0,j}) = w(A_{i,0})$. 
      
      Рассмотрим другое кодовое слово $A_{0,j'}$.
      $$d(A_{ij}, A_{0,j'}) = w(A_{ij} \oplus A_{0,j'})$$
        $$A_{ij} \oplus A_{0,j'} = 
      A_{i,0} \oplus \underbrace{A_{0,j} \oplus A_{0,j'}}_{\in C}$$
  Тогда $A_{ij} \oplus A_{0,j'}$ лежит в смежном классе $i$, значит
  $w(A_{ij} \oplus A_{0,j'}) \ge w(A_{i,0})$, что и требовалось.
\end{enumerate}
\end{proof}


\section{Полиномиальные коды}

\begin{definition}
Установим взаимно однозначной соответствие между многочленами степени 
$< n$ и двоичными векторами из $\tw^n$. 
$$\sum\limits_{i=0}^{n-1} g_i x^i \mapsto (x_0, \ldots, x_{n-1})
 \mapsto \sum\limits_{i=0}^{n-1} g_i x^i$$.
Тогда рассмотрим некоторый многочлен $g(x)$, тогда кодовые многочлены
получаются по правилу $b(x) = a(x) g(x)$, где $deg(a(x)) < k$. Тогда,
если $deg(g(x)) = n-k$, то получается $(n,k)$ код.
\end{definition}

\begin{example}
 $(6,4)$ код, с порождающим многочленом $1 + x + x^2$
 
 \begin{tabular}{ccc}
  $0 \, 0 \, 0 \, 1$ & $\overset{x^3}{\to}$ & $0 \, 0 \, 0 \, 1 \, 1 \, 1$ \\
  $0 \, 0 \, 1 \, 0$ & $\overset{x^2}{\to}$ & $0 \, 0 \, 1 \, 1 \, 1 \, 0$ \\
  $0 \, 1 \, 0 \, 0$ & $\overset{x}{\to}$ & $0 \, 1 \, 1 \, 1 \, 0 \, 0$ \\
  $1 \, 0 \, 0 \, 0$ & $\overset{1}{\to}$ & $1 \, 1 \, 1 \, 0 \, 0 \, 0$ \\     
 \end{tabular}
\end{example}

\section{Совершенные линейные коды}

\begin{definition}
Линейный $(n,k)$-код, исправляющий $r$ ошибок называется совершенным, если для него
достигается граница Хэмминга:
$$2^{n-k} = S_r(n)$$
\end{definition}

\begin{remark}
Для нелинейных кодов граница Хэмминга имеет вид
$$K = {2^n \over S_r(n)}$$
\end{remark}

\begin{example}
$(2m+1,1)$ код. Кодовые слова $\begin{pmatrix} 0 & \ldots & 0 \\ 1 & \ldots & 1 \end{pmatrix}$.
Этот код исправляет $m$ ошибок.
$$S_m(2m+1) = \sum\limits_{i=0}^{m} C_{2m+1}^i = 
{1 \over 2} \sum\limits_{i=0}^{m} (C_{2m+1}^i + C_{2m+1}^{2m+1-i}) = 2^{2m}$$
Тогда $2^{2m+1 - 1} = 2^{2m} = S_m(2m+1)$, что и требуется по определению.
\end{example}

\begin{example}
\label{perfect_hamming}
Код Хэмминга с $n = 2^m - 1$, $k = 2^m - 1 - m$, $m \ge 2$. Код исправляет одну ошибку,
$S_1(n) = 1 + n = 2^m$. Тогда
$$2^{n-k} = 2^{2^m - 1 - (2^m - 1 - m)} = 2^m = S_1(n)$$
\end{example}

\begin{theorem}
Cледующие условия равносильны
\begin{enumerate} 
\item Существует двоичный совершенный код $C$ в $\tw^{n}$, который исправляет
одну ошибку
\item $n = 2^m - 1$ 
\end{enumerate}
\end{theorem}

\begin{proof}
$2 \implies 1$ 
Должно выполняться $K = {2^n \over n+1}$. $K$ может быть целым, только если 
$n+1 = 2^m$ для некоторого m.

$1 \implies 2$ Доказали в примере \ref{perfect_hamming}.
\end{proof}

\begin{example}
$(23,12)$-код Голея, исправляющий $3$ ошибки. $S_3(23) = 1 + 23 + C_{23}^2 + C_{23}^3 
= 2048 = 2^{11}$. Тогда $2^{23} = S_3(23) \cdot 2^{12}$.
\end{example}

\section{Двоичные циклические коды}
\subsection{Свойства циклического кода}
\begin{definition}
Линейный код $C$ называется циклическим, если $\forall b \in C \colon b^{(1)} \in C$,
где $(b_0, \ldots, b_{n-1})^{(1)} = (b_{n-1}, b_0, \ldots, b_{n-2})$

Аналогично обозначим $b^{(j)} = (b^{(j-1)})^{(1)}$ --- сдвиг на $j$ позиций вправо.
\end{definition}

\begin{definition}
Кодовым многочленом, соответствующим $b \in C$ назовем многочлен
$\sum\limits_{i=0}^{n-1} b_i x^i$
\end{definition}

\begin{theorem}
\label{mod_representation}
$b^{(j)}(x) = x^{j} b(x) \mod (x^n + 1)$
\end{theorem}

\begin{proof}
Распишем $x^j b(x)$:
$$x^j b(x) = \sum\limits_{i=0}^{n-j-1} b_i x^{i+j} + \sum\limits_{i=n-j}^{n-1} b_i x^{i+j}
   = \sum\limits_{i=0}^{n-j-1} b_i x^{i+j} + x^n 
     \underbrace{\sum\limits_{i=n-j}^{n-1} b_i x^{i+j-n}}_{q(x)}$$
Рассмотрим многочлен $q(x) = b_{n-j} + b_{n-j+1} x + \ldots + b_{n-1} x^{j-1}$ и
прибавм его дважды к $x^j b(x)$ ($q(x) + q(x) = 0$):
$$x^j b(x) = \underbrace{ b_{n-j} + b_{n-j+1} x + \ldots + b_{n-1} x^{j-1}}_{q(x)}
           + b_0 x^j + \ldots + b_{n-j-1} x^{n-1} + x^n q(x) + q(x)$$
Тогда по модулю $x^n + 1$ получаем $b^{(j)}(x)$
\end{proof}

\begin{theorem}
\label{min_poly}
В циклическом коде существует только один ненулевой многочлен минимальной
степени.
\end{theorem}

\begin{proof}
Пусть есть два таких многочлена $q_1(x) = x^m + \ldots$; $q_2(x) = x^m + \ldots$.
Тогда из линейности кода $q_1(x) + q_2(x) \in C(x)$. Но 
$$(q_1 + q_2)(x) = \underbrace{x^m + x^m}_{=0} + \underbrace{\ldots}_{deg < m}$$
тогда $q_1$ и $q_2$ не минимальны по степени. противоречие.
\end{proof}

\begin{definition}
Кодовый многочлен $g(x)$ минимальной степери среди многочленов $C(x)$ называется
порождающим многочленом $C$.
\end{definition}

\begin{theorem}
Свободный член $g(x)$ --- порождающего многочлена циклического кода, равен $1$.
\end{theorem}

\begin{proof}
Пусть $g_0 = 0$, тогда $g_1 + g_2 x + \ldots + g_{n-1} x^{n-2} \in C(x)$, но его
степень меньше, чем у $g$. Противоречие.
\end{proof}

\begin{theorem}
Пусть $g(x)$ --- порождающий многочлен для циклического кода длины $n$.
Тогда $b(x) \in C(x) \iff b(x) \text{ кратно } g(x)$.
\end{theorem}

\begin{proof}
$\Leftarrow$ Пусть $b(x) = g(x) \cdot a(x)$. $deg(a) \le n-m-1$, тогда
  $$b(x) = g(x) \sum\limits_{i=0}^{n-m-1} a_i x^i =  
  \sum\limits_{i=0}^{n-m-1} a_i \underbrace{g(x) x^i}_{=g^{(i)}(x)}$$
таким образом, $b(x)$ представлен в виде линейной комбинации циклических
сдвигов $g(x)$, то есть $b(x) \in C(x)$

$\Rightarrow$ Пусть $b(x) \in C(x)$. Можно записать $b(x) = g(x) \cdot q(x) + r(x)$.
Нужно показать, что $r(x) = 0$
$$r(x) = \underbrace{b(x)}_{\in C(x)} + \underbrace{g(x) q(x)}_{\in C(x)}$$
Тогда $r(x) \in C(x)$. $deg(r(x)) < deg(g(x))$, тогда по теореме \ref{min_poly}
$r(x) = 0$.
\end{proof}


\begin{theorem}
Пусть код порождается многочленом $g(x)$. Тогда следующие условия равносильны
\begin{enumerate}
\item $C$ является циклическим
\item $g(x)$ --- делитель $x^n + 1$
\end{enumerate}
\end{theorem}

\begin{proof}
$1 \implies 2$ Рассмотрим $b \in C$. По теореме \ref{mod_representation} имеем
$b(x) x^j = b^{(j)}(x) + (x^n + 1) q(x)$. Выберем $j$ так, чтобы $deg(b(x) x^j) = n$,
тогда $q(x) = 1$. Тогда 
$$\exists j \in \{0, \ldots, n-1\} \colon x^j b(x) = b^{(j)}(x) + (x^n + 1)$$
Так как $C$ циклический и порождается $g(x)$, то $b^{(j)}(x) = g(x) a_j(x)$.
Тогда 
$$\underbrace{x^j b(x)}_{\text{кратно }g(x)} = 
\underbrace{b^{(j)}(x)}_{\text{кратно } g(x)} + (x^n + 1)$$
Тогда и $x^n + 1$ кратно $g(x)$.

$2 \implies 1$ Снова запишем
$$x^j b(x) = b^{(j)}(x) + (x^n + 1) q(x)$$
Тогда
$$b^{(j)}(x) = \underbrace{x^j b(x)}_{\text{кратно }g(x)} 
             + \underbrace{(x^n+1)}_{\text{кратно } g(x)}q(x)$$
Таким образом, код циклический.
\end{proof}

\subsection{Порождающая и проверочная матрицы циклического кода}
Пусть $C$ --- циклический код с порождающим многочленом 
$g(x) = 1 + g_1 x + \ldots + g_{r-1} x^{r-1} + x^r$. Тогда все кодовые
многочлены имеют вид 
$$b(x) = g(x) \underbrace{a(x)}_{deg = k-1} = a_0 g(x) + a_1 x g(x) + \ldots + a_{k-1} x^{k-1} g(x)$$
То есть, любой кодовый многочлен представляется как линейная комбинация многочленов
$x^j g(x)$. Тогда порождающая матрица имеет вид:
$$G = \begin{pmatrix} 1 & g_1 & g_2 & \ldots & g_{r-1} & 1 & 0 & \ldots  & 0 \\
                  0 & 1 & g_1   & \ldots & g_{r-2} & g_{r-1} & 1 & \ldots & 0 \\
                  \ldots   & \ldots   &   \ldots & \ldots & \ldots &\ldots &\ldots & \ldots &  \\
                  0 & \ldots  &\ldots  & 1 & g_1 & \ldots           &   & g_{r-1} & 1 \\
  \end{pmatrix}$$  

Теперь построим проверочную матрицу. Рассмотрим $h(x)$, такой, что $x^n + 1 = h(x) g(x)$.
Тогда рассмотрим произвольный кодовый многочлен $b(x) = q(x) g(x)$. 
$$b(x) h(x) = q(x) g(x) h(x) = q(x) (x^n + 1) = q(x) + x^n a(x)$$
Заметим, что $deg(a(x)) \le k-1$, а мономы $x^n a(x)$ имеют степень не менее $n$
тогда коэффициенты $b(x) h(x)$ при $x^k, x^{k+1}, \ldots, x^{n-1}$ равны нулю.
Давайте выразим эти коэффициенты через коэффициенты $b$ и $h$:
$$\begin{array}{l}
  \sum\limits_{i=0}^k b_i h_{k-i} = 0 \\
  \sum\limits_{i=0}^k b_{i+1} h_{k-i} = 0 \\
  \ldots
\end{array}$$
Тогда в матричном виде это выглядит как:

$$H = \begin{pmatrix} h_k & h_{k-1} & h_{k-2} & \ldots & h_1 & h_0 & 0 & \ldots  & 0 \\
                 0 & h_k & g_{k-1}   & \ldots & h_{2} & h_{1} & h_0 & \ldots & 0 \\
                 \ldots   & \ldots   &   \ldots & \ldots & \ldots &\ldots &\ldots & \ldots &  \\
                0 & \ldots  &\ldots  & h_k & g_{k-1} & \ldots           &   & h_{1} & h_0 \\
  \end{pmatrix}$$  
  
\begin{remark}
Строки в $G$ и $H$ линейно независимы, поскольку у 
каждой строки есть компонент, отсутствующий во всех строках с большими
номерами. Формально можно доказать по индукции.
\end{remark}

\begin{remark}
Порождающим многочленом дуального кода, порожденного многочленом $g(x)$ 
с проверочным многочленом $h(x)$ является многочлен $x^k h(x^{-1})$.
\end{remark}
\begin{proof}
Многочлен $x^k h(x^{-1}) = h_k + x h_{k-1} + \ldots + x^{k-1} h_1 + x^k h_0$,
то есть, это многочлен $h(x)$ с развернутыми коэффициентами. Тогда порождающая
матрица для этого многочлена совпадает с проверочной для кода, порожденного
$C$.
\end{proof}

\section{Модификации линейных кодов}
\begin{definition}
$\left(n+1,k\right)$-код, полученный из $\left(n,k\right)$-кода
добавлением одного контрольного бита (иначе говоря, дополнительной
переменной), называется \emph{расширенным кодом (extended code)}.
\end{definition}
Вообще говоря, добовлять можем любой бит, но это не всегда имеет смысл.
\begin{proposition}
Любой $\left(n,k,d\right)$-код с нечётным кодовым расстоянием можно
расширить до $\left(n+1,k,d+1\right)$-кода добавлением бита проверки
чётности.\end{proposition}
\begin{proof}
Если между двумя словами было расстояние $d$, то одно из них имеет
чётный вес, а другое нечётный, т.к. $d$ нечётно. Тогда очевидно,
что добавление бита проверки чётности увеличит расстояние между ними.\end{proof}
\begin{definition}
$\left(n-1,k\right)$-код, полученный из $\left(n,k\right)$-кода
удалением одного из контрольных битов (удалением переменной), называется
\emph{проколотым кодом (punctured code)}.
\end{definition}
Если расширим код, а затем уменьшим его на тот же контрольный бит,
на который увеличивали, получим исходный код.



Если удаляемый бит принимает значение 1 в кодовом слове минимального
веса, то минимальное кодовое расстояние уменьшается.


\begin{definition}
Код, полученный удалением информационных битов, называется \emph{укороченным
кодом (shortened code)}.
\end{definition}
Это значит удаление строки из порождающей матрицы и удаление столбца
из проверочной. Т.е. $\left(n,k\right)$-код превращается в $\left(n-1,k-1\right)$-код.
\begin{definition}
Код, полученный добавлением информационного бита, называется \emph{удлинённым
кодом (lengthened code)}.
\end{definition}
Это значит, что мы добавили строку в порождающую матрицу и столбец
в проверочную. Т.е. $\left(n,k\right)$-код превращается в $\left(n+1,k+1\right)$-код.
\begin{definition}
Код, полученный удалением некоторых кодовых слов, называется \emph{суженным
кодом (expurgated code)}.
\end{definition}
Возможно построить суженный код так, чтобы он оставался линейным.



Минимальное кодовое расстояние может увеличиться.
\begin{definition}
Код, полученный добавлением новых кодовых слов, называется \emph{дополненным
кодом (augmented code)}.




\end{definition}
\begin{example}
$\left(7,4\right)$-код Хэмминга. 

Построим расширенный код двум способами: начиная с проверочной матрицы
и начиная с порождающей. Новая переменная --- дополнительная проверка
чётности для всех битов.\end{example}
\begin{enumerate}
\item Проверочная матрица 
$$H=\left[\begin{array}{cccccccc}
1 & 0 & 0 & 1 & 0 & 1 & 1 & |0\\
0 & 1 & 0 & 1 & 1 & 1 & 0 & |0\\
0 & 0 & 1 & 0 & 1 & 1 & 1 & |0\\
\overline{1} & \overline{1} & \overline{1} & \overline{1} & \overline{1} & \overline{1} & \overline{1} & 1
\end{array}\right]$$
Последняя строка соответствует уравнению $\sum\limits_{i=0}^{6} x_i = x_7$, то
есть $x_7$ --- бит проверки четности.\\
Линейными преобразованиями получим $$H=\left[\begin{array}{cccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 0 & 1\\
0 & 1 & 0 & 0 & 0 & 1 & 1 & 1\\
0 & 0 & 1 & 0 & 1 & 1 & 1 & 0\\
0 & 0 & 0 & 1 & 1 & 0 & 1 & 1
\end{array}\right]$$ \\
Ей соответствует порождающая матрица $$G=\left[\begin{array}{cccccccc}
1 & 0 & 1 & |1| & 1 & 0 & 0 & 0\\
1 & 1 & 1 & |0| & 0 & 1 & 0 & 0\\
0 & 1 & 1 & |1| & 0 & 0 & 1 & 0\\
1 & 1 & 0 & |1| & 0 & 0 & 0 & 1
\end{array}\right]$$ 
 соответствующая начальной порождающей, к которой добавили 1 столбец
(4-ый).
\item Порождающая матрица $$G=\left[\begin{array}{cccccccc}
1 & 0 & 1 & |?| & 1 & 0 & 0 & 0\\
1 & 1 & 1 & |?| & 0 & 1 & 0 & 0\\
0 & 1 & 1 & |?| & 0 & 0 & 1 & 0\\
1 & 1 & 0 & |?| & 0 & 0 & 0 & 1
\end{array}\right]$$. Добавим такой столбец, что количество единиц в каждой строке
чётно. Легко видеть, что это тот же столбец, который мы получили в
первом случае и других быть не может.\\
Почему появляется условие чётности по строкам? Вспомним,$G=\left(\Gamma^{t}|E\right),H=\left(E|\Gamma\right)$.
От $H$ хотим, чтобы линейными преобразованиями над строками можно
было получить строку из всех единиц. Поскольку в $H$ есть единичная
подматрица, единственный способ это сделать --- просуммировать все
строки с коэффициентами 1. Тогда нам необходимо, чтобы все столбцы
$\Gamma$ были веса 1, то есть чтобы все строки $\Gamma^{t}$ были
веса 1. Следовательно, все строки $G$ должны иметь вес 0. \end{enumerate}
\begin{proposition}
При удлинении и при укорочении минимальное кодовое расстояние не меняется.\end{proposition}
\begin{proof}
~\\
\begin{enumerate}
\item При удлинении очевидно.
\item При укорочении происходит следующее: из $G$ вычёркивается строка
и соответствующий её столбец \emph{единичной подматрицы}. Соответственно,
вычёркивается столбец из проверочной матрицы.\\
Любая линейная комбинация строк $G$ имеет вес как минимум $d$. 
\[
a_{1}g_{1}+\ldots+a_{n}g_{n}\geq d,\;\forall\left\{ a_{i}\right\} 
\]
Вычёркивание $i$-ой строки и соответствующего ей столбца --- это
линейная комбинация с $a_{i}=0$.\end{enumerate}
\end{proof}

\section{Бинарные коды Голея}

Чтобы бинарный $(n,k,d)$-код был совершенным, необходимо выполнение условия плотной
упаковки: $$K \sum\limits_{k=0}^{\lfloor {d-1 \over 2} \rfloor} C_n^k = 2^n$$
Голей нашел два возможных кандидата: $(23,12,7)$ и $(90,78,5)$.

\begin{theorem}
Не существует бинарного $(90,78,5)$-кода.
\end{theorem}

\begin{proof}
Предположим, что существует $C$ --- $(90,78,5)$-код. Не умаляя общности 
можем считать, что $0 \in C$ (иначе выберем любой вектор $C$ и прибавим его
ко всем векторам кода). 

Пусть $Y = \{y \in \tw^{90} \colon y_0 = y_1 = 1 \land w(y) = 3 \}$. Очевидно,
$|Y| = 88$. Так как $C$ --- совершенный код, каждому $y \in Y$ соответствует
единственный $x \in C$ причем $d(x,y) = 2$
\end{proof}
